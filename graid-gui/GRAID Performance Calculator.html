<!DOCTYPE html>
<!-- saved from url=(0075)https://vodka.office.graidtech.com/QA/personal/aaron/graid_performance.html -->
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  
  <title>GRAID Performance Calculator</title>
  <style>
    body { font-family: sans-serif; padding: 2em; max-width: 800px; margin: auto; }
    label { display: block; margin: 10px 0 5px; }
    input, select { margin-left: 10px; }
    table { border-collapse: collapse; margin-top: 1.5em; width: 100%; }
    th, td { border: 1px solid #ccc; padding: 8px; text-align: left; }
    th { background-color: #f4f4f4; }
    h2 { margin-bottom: 0.5em; }
    .baseline-note {
        color: #007BFF;
        font-weight: bold;
    }
  </style>
</head>
<body data-new-gr-c-s-check-loaded="14.1267.0" data-gr-ext-installed="">

<h2>GRAID Theoretical Performance Calculator v1.2</h2>

<label>Number of PDs (SSDs):
  <input type="number" id="numDrives" value="12">
</label>

<label>Single PD 4K Random Read IOPS:
  <input type="number" id="iopsRead4k" value="1">
  <select id="unitRead4k">
    <option value="1000" selected="">k</option>
    <option value="1000000">M</option>
  </select>
</label>

<label>Single PD 4K Random Write IOPS:
  <input type="number" id="iopsWrite4k" value="600">
  <select id="unitWrite4k">
    <option value="1000" selected="">k</option>
    <option value="1000000">M</option>
  </select>
</label>

<label>Single PD 4K 50/50 Mixed IOPS:
  <input type="number" id="iopsMixed4k" value="400">
  <select id="unitMixed4k">
    <option value="1000" selected="">k</option>
    <option value="1000000">M</option>
  </select>
</label>

<label>Single PD 64K Random Read Throughput:
  <input type="number" id="randRead64k" value="5">
  <select id="unitRead64k">
    <option value="0.001">kB/s</option>
    <option value="1" selected="">MB/s</option>
    <option value="1000">GB/s</option>
  </select>
</label>

<label>Single PD 64K Random Write Throughput:
  <input type="number" id="randWrite64k" value="2">
  <select id="unitWrite64k">
    <option value="0.001">kB/s</option>
    <option value="1" selected="">MB/s</option>
    <option value="1000">GB/s</option>
  </select>
</label>

<label>Platform Baseline 4K Random Read IOPS:
    <input type="number" id="platformBaselineIOPS" value="20">
    <select id="platformBaselineUnit">
      <option value="1000">k</option>
      <option value="1000000" selected="">M</option>
      <option value="1000000000">B</option>
    </select>
</label>
<hr>
<label>Upload the single PD FIO test log:
    <input type="file" id="fioLog" accept=".log,.txt">
</label>

<label>Upload the platform baseline FIO log:
    <input type="file" id="baselineFioLog" accept=".log,.txt">
</label>
 
<button onclick="generateTable()">Generate GRAID Performance Table</button>
<button onclick="clearTable()">Clear Table</button>

<div id="output"><table><thead><tr><th>RAID Type</th><th>Workload</th><th>Performance</th><th>Calculation or Note</th></tr></thead><tbody><tr><td rowspan="4">RAID0</td>
        <td>4K Random Read</td><td>12M IOPS</td><td>1M IOPS x 12 = 12M IOPS<br><span class="baseline-note"></span></td></tr><tr><td>4K Random Write</td><td>7.2M IOPS</td><td>600k IOPS x 12</td></tr><tr><td>1M Sequential Read</td><td>138 GB/s</td><td>11.5 GB/s x 12 (Typically higher)</td></tr><tr><td>1M Sequential Write</td><td>84 GB/s</td><td>7 GB/s x 12 (Typically higher)</td></tr><tr><td rowspan="4">RAID1</td>
        <td>4K Random Read</td><td>12M IOPS</td><td>1M IOPS x 12 = 12M IOPS<br><span class="baseline-note"></span></td></tr><tr><td>4K Random Write</td><td>600k IOPS</td><td>600k IOPS x 1 (since every drive is writing the same data)</td></tr><tr><td>1M Sequential Read</td><td>138 GB/s</td><td>11.5 GB/s x 12</td></tr><tr><td>1M Sequential Write</td><td>7 GB/s</td><td>7 GB/s x 1</td></tr><tr><td rowspan="4">RAID10</td>
        <td>4K Random Read</td><td>12M IOPS</td><td>1M IOPS x 12 (Probably lower than this number slightly)<br><span class="baseline-note"></span></td></tr><tr><td>4K Random Write</td><td>3.6M IOPS</td><td>600k IOPS x 12 / 2 (given mirrored pairs)</td></tr><tr><td>1M Sequential Read</td><td>138 GB/s</td><td>11.5 GB/s x 12</td></tr><tr><td>1M Sequential Write</td><td>42 GB/s</td><td>7 GB/s x 12 / 2</td></tr><tr><td rowspan="4">RAID5</td>
        <td>4K Random Read</td><td>12M IOPS</td><td>1M IOPS x 12 = 12M IOPS<br><span class="baseline-note"></span></td></tr><tr><td>4K Random Write</td><td>2.4M IOPS</td><td>400k IOPS x 12 / 2 (considering single parity)</td></tr><tr><td>1M Sequential Read</td><td>138 GB/s</td><td>11.5 GB/s x 12</td></tr><tr><td>1M Sequential Write</td><td>69.3 GB/s</td><td>7 GB/s x (12 - 1) * 0.9, as one drive's capacity is used for parity</td></tr><tr><td rowspan="4">RAID6</td>
        <td>4K Random Read</td><td>12M IOPS</td><td>1M IOPS x 12 = 12M IOPS<br><span class="baseline-note"></span></td></tr><tr><td>4K Random Write</td><td>1.6M IOPS</td><td>400k IOPS x 12 / 3 (considering double parity)</td></tr><tr><td>1M Sequential Read</td><td>138 GB/s</td><td>11.5 GB/s x 12</td></tr><tr><td>1M Sequential Write</td><td>63 GB/s</td><td>7 GB/s x (12 - 2) * 0.9, as the capacity of two drives is used for parity</td></tr></tbody></table></div>

<script>
// JSON-based fio result auto-fill
document.getElementById('fioLog').addEventListener('change', function () {
  const file = this.files[0];
  if (!file) return;

  const reader = new FileReader();

  reader.onload = function (e) {
    let json;
    try {
    json = JSON.parse(e.target.result);
    } catch (err) {
    alert(
        "❌ Failed to parse fio JSON.\n\n" +
        "Please make sure you used:\n  --output-format=json\n\n" +
        "And ensure the file includes all the following job names:\n" +
        "  [4k_random_read]\n" +
        "  [4k_random_write]\n" +
        "  [4k_random_50read_50write]\n" +
        "  [64k_random_read]\n" +
        "  [64k_random_write]"
    );
    return;
    }

    const jobs = json.jobs;
    if (!Array.isArray(jobs) || jobs.length === 0) {
      alert("No job data found in fio JSON file.");
      return;
    }
    

    // Match each job by name
    const job4kRead = findJob(jobs, "4k_random_read");
    const job4kWrite = findJob(jobs, "4k_random_write");
    const job4kMixed = findJob(jobs, "4k_random_50read_50write");
    const job64kRead = findJob(jobs, "64k_random_read");
    const job64kWrite = findJob(jobs, "64k_random_write");

    // Fill IOPS values
    if (job4kRead) setIOPSField("iopsRead4k", job4kRead.read.iops, "unitRead4k");
    if (job4kWrite) setIOPSField("iopsWrite4k", job4kWrite.write.iops, "unitWrite4k");
    if (job4kMixed) setIOPSField("iopsMixed4k", job4kMixed.write.iops, "unitMixed4k"); // Mixed = read path
    console.log("job4kRead.read.iops: " + job4kRead.read.iops);
    console.log("job4kWrite.write.iops: " + job4kWrite.write.iops);
    console.log("job4kMixed.write.iops: " + job4kMixed.write.iops);

    // Fill bandwidth values (unit = KB/s)
    if (job64kRead) setBWField("randRead64k", job64kRead.read.bw, "unitRead64k");
    if (job64kWrite) setBWField("randWrite64k", job64kWrite.write.bw, "unitWrite64k");

    console.log("job64kRead.read.bw: " + job64kRead.read.bw);
    console.log("job64kWrite.write.bw: " + job64kWrite.write.bw);

    alert("✅ Fio JSON parsed successfully.");
  };

  reader.readAsText(file);
});

document.getElementById('baselineFioLog').addEventListener('change', function () {
  const file = this.files[0];
  if (!file) return;

  const reader = new FileReader();

  reader.onload = function (e) {
    let json;
    try {
      json = JSON.parse(e.target.result);
    } catch (err) {
      alert("❌ Failed to parse platform fio JSON.\nMake sure it's in JSON format and contains read.iops.");
      return;
    }

    try {
      const job = findJob(json.jobs, "nvme", false);

      if (!job || !job.read || typeof job.read.iops !== "number") {
        throw new Error("read.iops not found");
      }

      const iops = job.read.iops;
      console.log("platform_iops: " + iops);


      let displayValue = iops;
      let unit = 1;

      if (iops >= 1_000_000_000) {
        displayValue = iops / 1_000_000_000;
        unit = 1_000_000_000;
      } else if (iops >= 1_000_000) {
        displayValue = iops / 1_000_000;
        unit = 1_000_000;
      } else if (iops >= 1_000) {
        displayValue = iops / 1_000;
        unit = 1_000;
      }

      document.getElementById('platformBaselineIOPS').value = displayValue.toFixed(1);
      document.getElementById('platformBaselineUnit').value = unit;

      alert("✅ Platform baseline IOPS parsed successfully.");
    } catch (err) {
      alert("❌ Failed to extract job.read.iops from JSON.");
    }
  };

  reader.readAsText(file);
});


function findJob(jobs, name, exact = true) {
  return jobs.find(j => exact ? j.jobname === name : j.jobname.includes(name));
}

function setIOPSField(id, value, unitSelectId, baseUnit = 1000000) {
  if (!value) return;

  let displayValue = value;
  let unit = baseUnit;

  if (value >= 1_000_000_000) {
    displayValue = value / 1_000_000_000;
    unit = 1_000_000_000;
  } else if (value >= 1_000_000) {
    displayValue = value / 1_000_000;
    unit = 1_000_000;
  } else if (value >= 1_000) {
    displayValue = value / 1_000;
    unit = 1_000;
  }

  document.getElementById(id).value = displayValue.toFixed(1);
  document.getElementById(unitSelectId).value = unit;
}

// Format and set Bandwidth input & unit dropdown
function setBWField(id, bwKB, unitSelectId) {
  if (!bwKB) return;

  let value = bwKB / 1000; // Convert to MB/s
  let unit = 1000;         // Default to GB/s

  if (value >= 1000) {
    value = value / 1000;
    unit = 1000;
  } else if (value >= 1) {
    unit = 1;
  } else {
    value = value * 1000;
    unit = 0.001;
  }

  document.getElementById(id).value = value.toFixed(1);
  document.getElementById(unitSelectId).value = unit;
}

function clearTable() {
  document.getElementById('output').innerHTML = "";
}    

function trimDecimal(value) {
  const fixed = value.toFixed(1);
  return fixed.endsWith('.0') ? parseInt(fixed).toString() : fixed;
}

function formatIOPS(value) {
  if (value >= 1_000_000_000) {
    return trimDecimal(value / 1_000_000_000) + "B IOPS";
  } else if (value >= 1_000_000) {
    return trimDecimal(value / 1_000_000) + "M IOPS";
  } else if (value >= 1_000) {
    return trimDecimal(value / 1_000) + "k IOPS";
  } else {
    return value.toFixed(0) + " IOPS";
  }
}

function formatThroughput(valueInMBps) {
  if (valueInMBps >= 1000) {
    return trimDecimal(valueInMBps / 1000) + " GB/s";
  } else if (valueInMBps >= 1) {
    return trimDecimal(valueInMBps) + " MB/s";
  } else {
    return trimDecimal(valueInMBps * 1000) + " kB/s";
  }
}

function generateTable() {
    const numDrives = parseInt(document.getElementById('numDrives').value);

    // IOPS
    const iopsRead4kInput = parseFloat(document.getElementById('iopsRead4k').value);
    const iopsRead4kUnit = document.getElementById('unitRead4k').value;
    const iopsRead4k = iopsRead4kInput * parseFloat(iopsRead4kUnit);

    const iopsWrite4kInput = parseFloat(document.getElementById('iopsWrite4k').value);
    const iopsWrite4kUnit = document.getElementById('unitWrite4k').value;
    const iopsWrite4k = iopsWrite4kInput * parseFloat(iopsWrite4kUnit);

    const iopsMixed4kInput = parseFloat(document.getElementById('iopsMixed4k').value);
    const iopsMixed4kUnit = document.getElementById('unitMixed4k').value;
    const iopsMixed4k = iopsMixed4kInput * parseFloat(iopsMixed4kUnit);

    // Throughput
    const seqReadInput = parseFloat(document.getElementById('randRead64k').value);
    const seqReadUnit = document.getElementById('unitRead64k').value;
    const seqRead = seqReadInput * parseFloat(seqReadUnit); // in MB/s

    const seqWriteInput = parseFloat(document.getElementById('randWrite64k').value);
    const seqWriteUnit = document.getElementById('unitWrite64k').value;
    const seqWrite = seqWriteInput * parseFloat(seqWriteUnit); // in MB/s

    // System Overall Baseline input
    const baselineInput = parseFloat(document.getElementById('platformBaselineIOPS').value);
    const baselineUnit = parseFloat(document.getElementById('platformBaselineUnit').value);
    const baselineIOPS = baselineInput * baselineUnit;
  
    const raids = ['RAID0', 'RAID1', 'RAID10', 'RAID5', 'RAID6'];
    
    let html = '<table><thead><tr><th>RAID Type</th><th>Workload</th><th>Performance</th><th>Calculation or Note</th></tr></thead><tbody>';

    raids.forEach(raid => {
        const readIOPS = iopsRead4k * numDrives;
        const mixedIOPS = iopsMixed4k * numDrives;
        const readBW = seqRead * numDrives; // MB/s
        let writeIOPS = 0;
        let writeBW = 0;
        let read4KNote = '';
        let write4KNote = '';
        let read1MNote = '';
        let write1MNote = '';
        let readIOPSDisplay;
        let readBaselineNote = '';

        if (baselineIOPS < readIOPS) {
            readIOPSDisplay = formatIOPS(baselineIOPS);
            readBaselineNote = `(Capped by platform baseline: ${formatIOPS(baselineIOPS)})`;
        } else {
            readIOPSDisplay = formatIOPS(readIOPS);
            readBaselineNote = '';
        }

    switch (raid) {
      case 'RAID0':
        writeIOPS = iopsWrite4k * numDrives;
        writeBW = seqWrite * numDrives;
        read4KNote = `${formatIOPS(iopsRead4k)} x ${numDrives} = ${formatIOPS(readIOPS)}`;
        write4KNote = `${formatIOPS(iopsWrite4k)} x ${numDrives}`
        read1MNote = `${formatThroughput(seqRead)} x ${numDrives} (Typically higher)`
        write1MNote = `${formatThroughput(seqWrite)} x ${numDrives} (Typically higher)`
        break;

      case 'RAID1':
        writeIOPS = iopsWrite4k;
        writeBW = seqWrite;
        read4KNote = `${formatIOPS(iopsRead4k)} x ${numDrives} = ${formatIOPS(readIOPS)}`;
        write4KNote = `${formatIOPS(iopsWrite4k)} x 1 (since every drive is writing the same data)`;
        read1MNote = `${formatThroughput(seqRead)} x ${numDrives}`
        write1MNote = `${formatThroughput(seqWrite)} x 1`;
        break;

      case 'RAID10':
        writeIOPS = iopsWrite4k * numDrives / 2;
        writeBW = seqWrite * numDrives / 2;
        read4KNote = `${formatIOPS(iopsRead4k)} x ${numDrives} (Probably lower than this number slightly)`;
        write4KNote = `${formatIOPS(iopsWrite4k)} x ${numDrives} / 2 (given mirrored pairs)`;
        read1MNote = `${formatThroughput(seqRead)} x ${numDrives}`
        write1MNote = `${formatThroughput(seqWrite)} x ${numDrives} / 2`;
        break;

      case 'RAID5':
        writeIOPS = iopsMixed4k * numDrives / 2;
        writeBW = seqWrite * (numDrives - 1) * 0.9;
        read4KNote = `${formatIOPS(iopsRead4k)} x ${numDrives} = ${formatIOPS(readIOPS)}`;
        write4KNote = `${formatIOPS(iopsMixed4k, iopsMixed4kUnit)} x ${numDrives} / 2 (considering single parity)`;
        read1MNote = `${formatThroughput(seqRead)} x ${numDrives}`
        write1MNote = `${formatThroughput(seqWrite)} x (${numDrives} - 1) * 0.9, as one drive's capacity is used for parity`;
        break;

      case 'RAID6':
        writeIOPS = iopsMixed4k * numDrives / 3;
        writeBW = seqWrite * (numDrives - 2) * 0.9;
        read4KNote = `${formatIOPS(iopsRead4k)} x ${numDrives} = ${formatIOPS(readIOPS)}`;
        write4KNote = `${formatIOPS(iopsMixed4k, iopsMixed4kUnit)} x ${numDrives} / 3 (considering double parity)`;
        read1MNote = `${formatThroughput(seqRead)} x ${numDrives}`
        write1MNote = `${formatThroughput(seqWrite)} x (${numDrives} - 2) * 0.9, as the capacity of two drives is used for parity`;
        break;
    }

    html += `<tr><td rowspan="4">${raid}</td>
        <td>4K Random Read</td><td>${readIOPSDisplay}</td><td>${read4KNote}<br><span class="baseline-note">${readBaselineNote}</span></td></tr>`;
    html += `<tr><td>4K Random Write</td><td>${formatIOPS(writeIOPS)}</td><td>${write4KNote}</td></tr>`;
    html += `<tr><td>1M Sequential Read</td><td>${formatThroughput(readBW)}</td><td>${read1MNote}</td></tr>`;
    html += `<tr><td>1M Sequential Write</td><td>${formatThroughput(writeBW)}</td><td>${write1MNote}</td></tr>`;
  });

  html += '</tbody></table>';
  document.getElementById('output').innerHTML = html;
}
</script>


</body><grammarly-desktop-integration data-grammarly-shadow-root="true"><template shadowrootmode="open"><style>
      div.grammarly-desktop-integration {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        white-space: nowrap;
        border: 0;
        -moz-user-select: none;
        -webkit-user-select: none;
        -ms-user-select:none;
        user-select:none;
      }

      div.grammarly-desktop-integration:before {
        content: attr(data-content);
      }
    </style><div aria-label="grammarly-integration" role="group" tabindex="-1" class="grammarly-desktop-integration" data-content="{&quot;mode&quot;:&quot;full&quot;,&quot;isActive&quot;:true,&quot;isUserDisabled&quot;:false}"></div></template></grammarly-desktop-integration></html>